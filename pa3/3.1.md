## 批处理系统

我们在 PA2 中已经实现了一个冯诺依曼计算机系统，并且已经在 AM 上把打字游戏运行起来了。有了 IOE，几乎能把各种小游戏移植到 AM 上来运行了。这些小游戏在计算机上的运行模式有一个特点，它们会独占整个计算机系统：我们可以在 NEMU 上一直玩打字游戏，不想玩的时候，我们就会退出 NEMU，然后重新运行超级玛丽来玩。

事实上，早期的计算机就是这样工作的：系统管理员给计算机加载一个特定的程序（其实是上古时期的打孔卡片），计算机就会一直执行这个程序，直到程序结束或者是管理员手动终止，然后再由管理员来手动加载下一个程序。当年的程序也远远不如你玩的超级玛丽这么酷炫，大多都是一些科学计算和物理建模的任务（比如弹道轨迹计算）。

后来人们就想，每次都要管理员来手动加载新的程序，这太麻烦了。能不能让管理员事先准备好一组程序，让计算机执行完一个程序之后，就自动执行下一个程序呢？这就是[批处理](https://en.wikipedia.org/wiki/Batch_processing)系统的思想，有了批处理系统之后，就可以解放管理员的双手了。而批处理系统的关键，就是要有一个后台程序，当一个前台程序执行结束的时候，后台程序就会自动加载一个新的前台程序来执行。

这样的一个后台程序，其实就是操作系统。对，你没有听错，这个听上去好像什么都没做的后台程序，就是操作系统！说起操作系统，也许你会马上想到安装包都有几个 GB 的 Windows。但实际上，历史上最早投入使用的操作系统 [GM-NAA I/O](https://en.wikipedia.org/wiki/GM-NAA_I/O) 在1956年就诞生了，而它的一个主要任务，就是上文提到的“自动加载新程序”。

{% panel style="info", title="什么是操作系统？（建议二周目思考）" %}

这可是个大问题，我们也鼓励你学习完操作系统课程之后再回来重新审视它。

{% endpanel %}

### 最简单的操作系统

那么，我们也来介绍一下在 PA 中使用的最简单的操作系统吧，它的名字叫 Nanos-lite。Nanos-lite 是南京大学操作系统 Nanos 的裁剪版, 是一个为 PA 量身订造的操作系统。通过编写 Nanos-lite 的代码，你将会认识到操作系统是如何使用机器提供的接口，来支撑程序的运行的。这也符合 PA 的终极目标。

框架代码中已经为大家准备好了 Nanos-lite 的代码。Nanos-lite 已经包含了后续 PA 用到的所有模块，由于硬件（NEMU）的功能是逐渐添加的，Nanos-lite 也要配合这个过程，你会通过 `nanos-lite/src/main.c` 中的一些与实验进度相关的宏来控制 Nanos-lite 的功能。随着实验进度的推进，我们会逐渐讲解所有的模块，Nanos-lite 做的工作也会越来越多。因此在阅读 Nanos-lite 的代码时，你只需要关心和当前进度相关的模块就可以了，不要纠缠于和当前进度无关的代码。

```
nanos-lite
├── include
│   ├── common.h
│   ├── debug.h
│   ├── fs.h
│   ├── memory.h
│   └── proc.h
├── Makefile
└── src
    ├── device.c   # 设备抽象
    ├── fs.c       # 文件系统
    ├── initrd.S   # ramdisk设备
    ├── irq.c      # 中断异常处理
    ├── loader.c   # 加载器
    ├── main.c
    ├── mm.c       # 存储管理
    ├── proc.c     # 进程调度
    ├── ramdisk.c  # ramdisk驱动程序
    └── syscall.c  # 系统调用处理
```

需要提醒的是，Nanos-lite 是运行在 AM 之上的，AM 的 API 在 Nanos-lite 中都是可用的。虽然操作系统对我们来说是一个特殊的概念，但在 AM 看来, 它只是一个使用 AM API 的普通 C 程序而已，和超级玛丽没什么区别。同时，你会再次体会到 AM 的好处：Nanos-lite 的实现可以是机器无关的，这意味着，你可以像开发 klib 那样，在 `native` 上调试你编写的 Nanos-lite。

另外，虽然不会引起明显的误解，但在引入 Nanos-lite 之后，我们还是会在某些地方使用“用户进程”的概念，而不是“用户程序”。如果你现在不能理解什么是进程，你只需要把进程作为“正在运行的程序”来理解就可以了。还感觉不出这两者的区别？举一个简单的例子吧，如果你打开了记事本 3 次，计算机上就会有 3 个记事本进程在运行，但磁盘中的记事本程序只有一个。进程是操作系统中一个重要的概念，有关进程的详细知识会在操作系统课上进行介绍。

一开始，在 `nanos-lite/src/main.c` 中所有与实验进度相关的宏都没有定义，此时 Nanos-lite 的功能十分简单。我们来简单梳理一下 Nanos-lite 目前的行为：

1. 通过 `Log()` 输出 hello 信息和编译时间。需要说明的是，Nanos-lite 中定义的 `Log()` 宏并不是 NEMU 中定义的 `Log()` 宏。Nanos-lite 和 NEMU 是两个独立的项目，它们的代码不会相互影响，你在阅读代码的时候需要注意这一点。在 Nanos-lite 中，`Log()` 宏通过 `klib` 中的 `printk()` 输出, 最终会调用 TRM 的 `_putc()`。
2. 初始化 ramdisk。在一个完整的模拟器中，程序应该存放在磁盘中。但目前我们并没有实现磁盘的模拟，因此先把 Nanos-lite 中的一段内存作为磁盘来使用。这样的磁盘有一个专门的名字，叫 ramdisk。
3. 调用 `init_device()` 对设备进行一些初始化操作。目前 `init_device()` 会直接调用 `_ioe_init()`。
4. 调用 `loader()` 函数加载用户程序，函数会返回用户程序的入口地址。其中 `loader()` 函数并未实现，我们会在下文进行说明。
5. 跳转到用户程序的入口执行。

### 加载操作系统的第一个用户程序

loader 是一个用于加载程序的模块。我们知道程序中包括代码和数据，它们都是存储在可执行文件中。加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置，然后跳转到程序入口，程序就开始执行了。更具体的，为了实现 `loader()` 函数，我们需要解决以下问题：

- 可执行文件在哪里?
- 代码和数据在可执行文件的哪个位置?
- 代码和数据有多少?
- "正确的内存位置"在哪里?

为了回答第一个问题，我们还要先说明一下用户程序是从哪里来的。由于用户程序运行在操作系统之上，不能与 AM 所提供的运行时环境相适配了，因此我们不能把编译到 AM 上的程序放到操作系统上运行。为此，我们准备了一个新的子项目 Navy-apps，专门用于编译出操作系统的用户程序。

```
navy-apps
├── apps            # 用户程序
│   ├── init
│   ├── litenes
│   ├── lua
│   ├── nterm
│   ├── nwm
│   └── pal         # 仙剑奇侠传
├── fsimg           # 根文件系统
├── libs            # 库
│   ├── libc        # Newlib C库
│   ├── libfont
│   ├── libndl
│   └── libos       # 系统调用的用户层封装
├── Makefile
├── Makefile.app
├── Makefile.check
├── Makefile.compile
├── Makefile.lib
├── README.md
└── tests           # 一些测试
```

其中，`navy-apps/libs/libc` 中是一个名为 Newlib 的项目，它是一个专门为嵌入式系统提供的 C 库，库中的函数对运行时环境的要求极低。这对 Nanos-lite 来说是非常友好的，我们不需要为了配合 C 库而在 Nanos-lite 中实现额外的功能。用户程序的入口位于 `navy-apps/libs/libc/src/start.c` 中的 `_start()` 函数，它会调用用户程序的 `main()` 函数，从 `main()` 函数返回后会调用 `exit()` 结束运行。

我们要在 Nanos-lite 上运行的第一个用户程序是 `navy-apps/tests/dummy/dummy.c`。首先我们让 Navy-apps 项目上的程序默认编译到`x86`中：

```diff
--- navy-apps/Makefile.check
+++ navy-apps/Makefile.check
@@ -1,1 +1,1 @@
-ISA ?= native
+ISA ?= x86
```

然后在 `navy-apps/tests/dummy` 下执行

```bash
make
```

就会在 `navy-apps/tests/dummy/build/` 目录下生成 dummy 的可执行文件。编译 Newlib 时会出现较多 warning，我们可以忽略它们。为了避免和 Nanos-lite 的内容产生冲突，我们约定目前用户程序需要被链接到内存位置 `0x4000000` 处，Navy-apps 已经设置好了相应的选项（见 `navy-apps/Makefile.compile` 中的 `LDFLAGS` 变量）。

在 `nanos-lite/` 目录下执行

```bash
make update
```

`nanos-lite/Makefile` 中会将其生成 ramdisk 镜像文件 `ramdisk.img`，并包含进 Nanos-lite 成为其中的一部分（在 `nanos-lite/src/initrd.S` 中实现）。现在的 ramdisk 十分简单，它只有一个文件，就是我们将要加载的用户程序，这其实已经回答了上述第一个问题：可执行文件位于 ramdisk 偏移为0处，访问它就可以得到用户程序的第一个字节。

为了回答剩下的问题，我们首先需要了解可执行文件是如何组织的。你应该已经在课堂上学习过 ELF 文件格式了，它除了包含程序本身的代码和静态数据之外，还包括一些用来描述它们的组织信息。事实上，我们的 loader 目前并没有必要去解析并加载ELF文件。为了简化，`nanos-lite/Makefile` 中已经把用户程序运行所需要的代码和静态数据通过 `objcopy` 工具从ELF文件中抽取出来了，整个 ramdisk 本身就已经存放了 loader 所需要加载的内容。最后，“正确的内存位置”，也就是我们上文提到的约定好的 `0x4000000` 了。

**所以，目前的 loader 只需要做一件事情：将 ramdisk 中从 0 开始的所有内容放置在 `0x4000000`，并把这个地址作为程序的入口返回即可。**我们把这个简化了的 loader 称为 raw program loader。我们通过内存布局来理解 loader 目前需要做的事情：

```
                ramdisk_start   ramdisk_end
                     |               |
                     +--+         +--+
0  0x100000             v         v           0x4000000
+------+------------------------------+-----------+-------+-------
|      |                +---------+   |           |       |
|      | Nanos-lite     | ramdisk |   |           | dummy |
|      |                +---------+   |           |       |
+------+------------------------------+-----------+-------+-------
                        |                         ^
                        +-------------------------+
                                   loader
```

框架代码提供了一些 ramdisk 相关的函数（在 `nanos-lite/src/ramdisk.c` 中定义），你可以使用它们来实现 loader 的功能：

```c
// 从ramdisk中`offset`偏移处的`len`字节读入到`buf`中
void ramdisk_read(void *buf, off_t offset, size_t len);

// 把`buf`中的`len`字节写入到ramdisk中`offset`偏移处
void ramdisk_write(const void *buf, off_t offset, size_t len);

// 返回ramdisk的大小, 单位为字节
size_t get_ramdisk_size();
```

真实操作系统中的 loader 远比我们目前在 Nanos-lite 中实现的 loader 要复杂。事实上，Nanos-lite 的 loader 设计其实也向我们展现出了程序的最为原始的状态：一个凝结着人类智慧设计的精妙算法，承载着人类劳动收集的宝贵数据的...比特串！加载程序其实就是把这一无比珍贵的比特串放置在正确的位置，但这看似平凡无比的比特串当中又蕴含着“存储程序”的划时代思想：当操作系统将控制权交给它的时候，计算机以把它解释成指令并逐条执行，却让这一比特串真正发挥出它足以改变世界的潜能。

{% panel style="danger", title="实现 loader" %}

你需要在 Nanos-lite 中实现 loader 的功能, 来把用户程序加载到正确的内存位置，然后执行用户程序。

`loader()` 函数在 `nanos-lite/src/loader.c` 中定义，其中的 `as` 参数目前暂不使用，可以忽略，而因为 ramdisk 中目前只要一个文件，`filename` 参数也可以忽略。

需要注意的是，每当 ramdisk 中的内容需要更新时，你都需要在 `nanos-lite/` 目录下手动执行

```bash
make update
```

来更新 Nanos-lite 中的 ramdisk 内容，然后再通过

```bash
make run
```

来在 NEMU 上运行带有最新版 ramdisk 的 Nanos-lite。

实现正确后，你会看到 dummy 程序执行了一条未实现的 `int` 指令，这说明 loader 已经成功加载 dummy，并且成功地跳转到 dummy 中执行了。未实现的 `int` 指令我们会接下来的内容中进行说明。

{% endpanel %}

## 等级森严的制度

为了阻止程序将执行流切换到操作系统的任意位置，硬件中逐渐出现保护机制相关的功能，比如 i386 中引入了保护模式（protected mode）和特权级（privilege level）的概念。简单地说，只有高特权级的程序才能去执行一些系统级别的操作，如果一个特权级低的程序尝试执行它没有权限执行的操作，CPU 将会抛出一个异常信号，来阻止这一非法行为的发生。一般来说，最适合担任系统管理员的角色就是操作系统了，它拥有最高的特权级，可以执行所有操作；而除非经过允许，运行在操作系统上的用户程序一般都处于最低的特权级，如果它试图破坏社会的和谐，它将会被判“死刑”。

在 i386 中，存在 0，1，2，3 四个特权级。0特权级最高，3特权级最低。特权级 n 所能访问的资源，在特权级 0~n 也能访问。不同特权级之间的关系就形成了一个环：内环可以访问外环的资源，但外环不能进入内环的区域，因此也有 "ring n" 的说法来描述一个进程所在的特权级。

```
              +---------------------------------------------------+
              | +-----------------------------------------------+ |
              | |                 APPLICATIONS                  | |
              | |     +-----------------------------------+     | |
              | |     |        CUSTOM EXTENSIONS          |     | |
              | |     |     +-----------------------+     |     | |
              | |     |     |    SYSTEM SERVICES    |     |     | |
              | |     |     |     +-----------+     |     |     | |
              | |     |     |     |    OS     |     |     |     | |
              |-|-----+-----+-----+-----+-----+-----+-----+-----|-|
              | |     |     |     |     |LEVEL|LEVEL|LEVEL|LEVEL| |
              | |     |     |     |     |  0  |  1  |  2  |  3  | |
              | |     |     |     +-----+-----+     |     |     | |
              | |     |     |           |           |     |     | |
              | |     |     +-----------+-----------+     |     | |
              | |     |                 |                 |     | |
              | |     +-----------------+-----------------+     | |
              | |                       |                       | |
              | +-----------------------+-----------------------+ |
              +------------------------+ +------------------------+
```

虽然 80386 提供了 4 个特权级，但大多数通用的操作系统只会使用 0 级和 3 级：操作系统处在 ring 0，一般的程序处在 ring 3，这就已经起到保护的作用了。那 CPU 是怎么判断一个进程是否执行了无权限操作呢？在这之前，我们还要简单地了解一下 i386 中引入的与特权级相关的概念：

- DPL(Descriptor Privilege Level)属性描述了一段数据所在的特权级
- RPL(Requestor's Privilege Level)属性描述了请求者所在的特权级
- CPL(Current Privilege Level)属性描述了当前进程的特权级

一次数据的访问操作是合法的，当且仅当

```
data.DPL >= requestor.RPL           # <1>
data.DPL >= current_process.CPL     # <2>
```

两式同时成立，注意这里的 `>=` 是数值上的（numerically greater）。

<1>式表示请求者有权限访问目标数据， <2>式表示当前进程也有权限访问目标数据。如果违反了上述其中一式，此次操作将会被判定为非法操作。CPU将会抛出异常信号，并跳转到一个和操作系统约定好的内存位置，交由操作系统进行后续处理。

{% panel style="info", title="对 RPL 的补充" %}

你可能会觉得 RPL 十分令人费解，我们先举一个生活上的例子。

- 假设你到银行找工作人员办理取款业务，这时你就相当于 requestor，你的账户相当于 data，工作人员相当于 current_process。业务办理成功是因为
  - 你有权限访问自己的账户（`data.DPL >= requestor.RPL`）
  - 工作人员也有权限对你的账户进行操作（`data.DPL >= current_process.CPL`）
- 如果你想从别人的账户中取钱，虽然工作人员有权限访问别人的账户（`data.DPL >= current_process.CPL`），但是你却没有权限访问（`data.DPL < requestor.RPL`），因此业务办理失败。
- 如果你打算亲自操作银行系统来取款，虽然账户是你的（`data.DPL >= requestor.RPL`），但是你却没有权限直接对你的账户金额进行操作（`data.DPL < current_process.CPL`），因此你很有可能会被抓起来。

在计算机中也存在类似的情况：用户进程（requestor）想对它自己拥有的数据（data）进行一些它没有权限的操作，它就要请求有权限的进程（current_process，通常是操作系统）来帮它完成这个操作，于是就会出现“操作系统代表用户进程进行操作”的场景。但在真正进行操作之前，也要检查这些数据是不是真的是用户进程有权使用的数据。

{% endpanel %}

通常情况下，操作系统运行在 ring 0，CPL 为 0，因此有权限访问所有的数据；而用户进程运行在 ring 3，CPL 为 3，这就决定了它只能访问同样处在 ring3 的数据。这样，只要操作系统将其私有数据放在 ring 0 中，恶意程序就永远没有办法访问到它们。这些保护相关的概念和检查过程都是通过硬件实现的，只要软件运行在硬件上面，都无法逃出这一天网。硬件保护机制使得恶意程序永远无法全身而退，为构建计算机和谐社会作出了巨大的贡献。

这是多美妙的功能！遗憾的是，上面提到的很多概念其实只是一带而过，真正的保护机制也还需要考虑更多的细节。i386 手册中专门有一章来描述保护机制，就已经看出来这并不是简单说说而已。根据 KISS 法则，我们并不打算在 NEMU 中加入保护机制。我们让所有用户进程都运行在 ring 0，虽然所有用户进程都有权限执行所有指令，不过由于 PA 中的用户程序都是我们自己编写的，一切还是在我们的控制范围之内。毕竟，我们也已经从上面的故事中体会到保护机制的本质了：在硬件中加入一些与特权级检查相关的门电路（例如比较器电路），如果发现了非法操作，就会抛出一个异常信号，让 CPU 跳转到一个约定好的目标位置。并进行后续处理。

{% panel style="info", title="分崩离析的秩序" %}

特权级保护是现代计算机系统的一个核心机制，但并不是有了这一等级森严的制度就在高枕无忧了，黑客们总是会绞尽脑汁去试探这一制度的边界。最近席卷计算机领域的，就要数 2018 年 1 月爆出的 [Meltdown 和 Spectre](https://meltdownattack.com/) 这两个大名鼎鼎的硬件漏洞了。这两个史诗级别的漏洞之所以震惊全世界，是因为它们打破了特权级的边界：恶意程序在特定的条件下可以以极高的效率窃取操作系统的信息。Intel 的芯片被爆都有 Meltdown 漏洞，而 Spectre 漏洞则是危害着所有架构的芯片，无一幸免，可谓目前为止体系结构历史上影响最大的两个漏洞了。如果你执行 `cat /proc/cpuinfo`，你应该会在 `bugs` 信息中看到这两个漏洞的影子。

Meltdown 和 Spectre 给过去那些一味追求性能的芯片设计师敲响了警钟：没有安全，芯片跑得再快，也是徒然。有趣的是，直接为这场闹剧买单的，竟然是各大云计算平台的工程师们：漏洞被爆出的那一周时间，阿里云和微软 Azure 的工程师连续通宵加班，想尽办法给云平台打上安全补丁，以避免客户的数据被恶意窃取。

不过作为教学实验，安全这个话题离 PA 还是太遥远了，甚至性能也不是 PA 的主要目标。这个例子想说的是，真实的计算机系统非常复杂，远远没到完美的程度。这些漏洞的出现从某种程度上也说明了，复杂程度已经到了人们没法一下子想明白每个模块之间的相互影响了；但计算机背后的原理都是一脉相承的，在一个小而精的教学系统中理解这些原理，然后去理解，去改进真实的系统，这也是做 PA 的一种宝贵的收获。

{% endpanel %}

### 操作系统的义务

既然操作系统位于 ring 0 享受着至高无上的权利，自然地它也需要履行相应的义务，那就是：管理系统中的所有资源，为用户进程提供相应的服务。举一个银行的例子，如果银行连最基本的取款业务都不能办理，是没有客户愿意光顾它的。但同时银行也不能允许客户亲自到金库里取款，而是需要客户按照规定的手续来办理取款业务。同样地，操作系统并不允许用户进程直接操作显示器硬件进行输出，否则恶意程序就很容易往显示器中写入恶意数据，让屏幕保持黑屏，影响其它进程的使用。因此，用户进程想输出一句话，也要经过一定的合法手续向操作系统进行申请，这一合法手续就是系统调用。

我们到银行办理业务的时候，需要告诉工作人员要办理什么业务，账号是什么，交易金额是多少，这无非是希望工作人员知道我们具体想做什么。用户进程执行系统调用的时候也是类似的情况，要通过一种方法描述自己的需求，然后告诉操作系统。用来描述需求最方便的手段就是使用通用寄存器了，用户进程将系统调用的参数依次放入各个寄存器中（第一个参数放在 `%eax` 中，第二个参数放在 `%ebx` 中...）。为了让操作系统注意到用户进程提交的申请，系统调用通常都会触发一个异常，然后陷入操作系统。在 GNU/Linux 中，系统调用产生的异常通过 `int $0x80` 指令触发。这个异常和上文提到的非法操作产生的异常不同，操作系统能够识别它是由系统调用产生的。

Navy-apps 已经为用户程序准备好了系统调用的接口了。`navy-apps/libs/libos/src/nanos.c` 中定义的 `_syscall_()` 函数已经蕴含着上述过程：

```c
int _syscall_(int type, uintptr_t a0, uintptr_t a1, uintptr_t a2) {
  int ret;
  asm volatile("int $0x80": "=a"(ret): "a"(type), "b"(a0), "c"(a1), "d"(a2));
  return ret;
}
```

上述内联汇编会先把系统调用的参数依次放入 `%eax`，`%ebx`，`%ecx`，`%edx` 四个寄存器中，然后执行 `int $0x80` 手动触发一个特殊的异常。操作系统捕获这个异常之后，发现是一个系统调用，就会调出相应的处理函数进行处理，处理结束后设置好返回值，然后返回到上述的内敛汇编中。内联汇编最后从 `%eax` 寄存器中取出系统调用的返回值，并返回给调用该接口的函数，告知其系统调用执行的情况（如是否成功等）。

我们可以在 GNU/Linux 下编写一个程序，来手工触发一次 `write` 系统调用：

```c
const char str[] = "Hello world!\n";

int main() {
  asm volatile ("movl $4, %eax;"      // system call ID, 4 = SYS_write
                "movl $1, %ebx;"      // file descriptor, 1 = stdout
                "movl $str, %ecx;"    // buffer address
                "movl $13, %edx;"      // length
                "int $0x80");

  return 0;
}
```

如果你在 64 位操作系统上运行它，你需要在编译的时候加入 `-m32` 参数来生成 32 位的代码。用户进程执行上述代码，就相当于告诉操作系统：帮我把从 `str` 开始的 13 字节写到 1 号文件中去. 其中“写到 1 号文件中去”的功能相当于输出到屏幕上。

虽然操作系统需要为用户进程服务，但这并不意味着操作系统需要把所有信息都暴露给用户程序。有些信息是用户进程没有必要知道的，也永远不应该知道，例如一些与内存管理相关的数据结构。如果一个恶意程序获得了这些信息，可能会为恶意攻击提供了信息基础。因此，通常不存在一个系统调用来获取这些操作系统的私有数据。

## 穿越时空的旅程

有了强大的硬件保护机制，用户程序将无法把执行流切换到操作系统的任意代码了。但为了实现最简单的操作系统，硬件还需要提供一种可以限制入口的执行流切换方式。在这里我们用异常来完成。异常是指 CPU 在执行过程中检测到的不正常事件，例如除数为零、无效指令、权限不足等。CPU 检测到异常之后，就会进入操作系统预先设置好的跳转目标。

i386提供 `int` 指令作为异常指令，它的工作过程十分特别，整个过程是由 i386 中断机制支撑的。i386 中断机制不具体区分 CPU 异常和自陷，而是对它们进行统一的处理。在 i386中，上述跳转目标是通过门描述符（Gate Descriptor）来指示的。门描述符是一个 8 字节的结构体，里面包含着不少细节的信息。我们在 NEMU 中简化了门描述符的结构，只保留存在位 P 和偏移量 OFFSET：

```
   31                23                15                7                0
  +-----------------+-----------------+---+-------------------------------+
  |           OFFSET 31..16           | P |          Don't care           |4
  +-----------------------------------+---+-------------------------------+
  |             Don't care            |           OFFSET 15..0            |0
  +-----------------+-----------------+-----------------+-----------------+
```

P 位来用表示这一个门描述符是否有效，OFFSET 用来指示跳转目标。有了门描述符，用户程序就只能跳转到门描述符中 OFFSET 所指定的位置，再也不能随心所欲地跳转到操作系统的任意代码了。

为了方便管理各个门描述符，i386 把内存中的某一段数据专门解释成一个数组，叫 IDT(Interrupt Descriptor Table, 中断描述符表)，数组的一个元素就是一个门描述符。为了从数组中找到一个门描述符，我们还需要一个索引。对于CPU异常来说，这个索引由 CPU 内部产生（例如除零异常为 0 号异常），或者由 `int` 指令给出（例如 `int $0x80`）。最后，为了在内存中找到 IDT，i386 使用 IDTR 寄存器来存放 IDT 的首地址和长度。操作系统的代码事先把 IDT 准备好，然后执行一条特殊的指令 `lidt`，来在 IDTR 中设置好 IDT 的首地址和长度，这一中断处理机制就可以正常工作了。现在是万事俱备，等到异常的东风一刮，CPU 就会按照设定好的 IDT 跳转到目标地址：

```
           |               |
           |   Entry Point |<----+
           |               |     |
           |               |     |
           |               |     |
           +---------------+     |
           |               |     |
           |               |     |
           |               |     |
           +---------------+     |
           |offset |       |     |
           |-------+-------|     |
Exception  |       | offset|-----+
   ID----->+---------------+
           |               |
           |Gate Descriptor|
           |               |
 IDT------>+---------------+
           |               |
           |               |
```

不过，我们将来还是有可能需要返回到程序的当前状态来继续执行的，比如通过 `int3` 触发的断点异常。这意味着，我们需要在进行异常处理之前保存好程序当前的状态。于是，触发异常后硬件的处理如下：

1. 依次将EFLAGS, CS(代码段寄存器), EIP寄存器的值压栈
2. 从IDTR中读出IDT的首地址
3. 根据异常号在IDT中进行索引, 找到一个门描述符
4. 将门描述符中的offset域组合成目标地址
5. 跳转到目标地址

需要注意的是，这些工作都是硬件自动完成的，不需要程序员编写指令来完成相应的内容。事实上，这只是一个简化后的过程，在真实的计算机上还要处理很多细节问题，在这里我们就不深究了。i386 手册中还记录了处理器对中断号和异常号的分配情况，并列出了各种异常的详细解释，需要了解的时候可以进行查阅。

由于 IDT 中的目标地址是硬件和操作系统约定好的，接下来的处理过程将会由操作系统来接管，操作系统将视情况决定是否终止当前程序的运行（例如触发段错误的程序将会被杀死）。若决定不杀死当前程序，等到异常处理结束之后，就根据之前保存的信息恢复程序的状态。`iret` 指令用于从异常处理过程中返回，它将栈顶的三个元素来依次解释成 EIP, CS, EFLAGS，并恢复它们。

在计算机和谐社会中，大部分门描述符都不能让用户进程随意使用，否则恶意程序就可以通过 `int` 指令欺骗操作系统。例如恶意程序执行 `int $0x2` 来谎报电源掉电，扰乱其它进程的正常运行。因此执行 `int`  指令也需要进行特权级检查，但PA 中就不实现这一保护机制了，具体的检查规则我们也就不展开讨论了，需要了解的时候请查阅 i386 手册。

### 加入 ASYE

在 AM 的模型中，异常处理的能力被划分到 ASYE 模块中。老规矩，我们还是分别从 NEMU 和 AM 两个角度来体会硬件和软件如何相互协助来支持 ASYE 的功能。

#### 准备 IDT

首先是要准备一个有意义的 IDT，这样以后触发异常时才能跳转到正确的目标地址。具体的，你需要在 NEMU 中添加 IDTR 寄存器和 `lidt` 指令。然后在 `nanos-lite/src/main.c` 中定义宏 `HAS_ASYE`，这样以后，Nanos-lite 会多进行一项初始化工作：调用 `init_irq()` 函数，这最终会调用位于 `nexus-am/am/arch/x86-nemu/src/asye.c` 中的 `_asye_init()` 函数。`_asye_init()` 函数会做两件事情，第一件就是初始化 IDT：

1. 代码定义了一个结构体数组 `idt`，它的每一项是一个门描述符结构体
2. 在相应的数组元素中填写有意义的门描述符，例如编号为 `0x80` 的门描述符就是将来系统调用的入口地址。需要注意的是，框架代码中还是填写了完整的门描述符（包括上文中提到的 don't care 的域），这主要是为了在 QEMU 中进行 differential testing 时也能跳转到正确的入口地址。QEMU 实现了完整的中断机制，如果只填写简化版的门描述符，就无法在 QEMU 中正确运行。但我们无需了解其中的细节，只需要知道代码已经填写了正确的门描述符即可。
3. 在 IDTR 中设置 `idt` 的首地址和长度

`_asye_init()` 函数做的第二件事是注册一个事件处理函数，这个事件处理函数由 `_asyn_init()` 的调用者提供。关于事件处理函数，我们会在下文进行更多的介绍。

#### 触发异常

为了测试是否已经成功准备 IDT，我们还需要真正触发一次异常，看是否正确地跳转到目标地址。具体的，你需要在 NEMU 中实现 `raise_intr()` 函数（在`nemu/src/cpu/intr.c` 中定义）来模拟上文提到的 i386 中断机制的处理过程：

```c
void raise_intr(uint8_t NO, vaddr_t save_addr) {
  /* TODO: Trigger an interrupt/exception with ``NO''.
   * That is, use ``NO'' to index the IDT.
   */

}
```

需要注意的是：

- PA 不涉及特权级的切换，查阅 i386 手册的时候你不需要关心和特权级切换相关的内容。
- 通过 IDTR 中的地址对 IDT 进行索引的时候，需要使用 `vaddr_read()`。
- PA 中不实现分段机制，没有 CS 寄存器的概念。但为了在 QEMU 中顺利进行 differential testing，我们还是需要在 cpu 结构体中添加一个 CS 寄存器, 并在 `restart()` 函数中将其初始化为 `8`。
- 由于中断机制需要对 EFLAGS 进行压栈，为了配合 differential testing，我们还需要在 `restart()` 函数中将 EFLAGS 初始化为 `0x2`。
- 执行 `int` 指令后保存的 `EIP` 指向的是 `int` 指令的下一条指令，这有点像函数调用，具体细节可以查阅 i386 手册。
- 你需要在 `int` 指令的 helper 函数中调用 `raise_intr()`，而不要把中断机制的代码放在 `int` 指令的 helper 函数中实现，因为在后面我们会再次用到 `raise_intr()` 函数。

{%panel style="danger", title="实现中断机制" %}

你需要实现上文提到的 `lidt` 指令和 `int` 指令，并实现 `raise_intr()` 函数。

实现正确后，重新在 Nanos-lite 上运行 dummy 程序，如果你看到在 `vecsys()` （在 `nexum-am/am/arch/x86-nemu/src/trap.S` 中定义）附近触发了未实现指令，说明你的中断机制实现正确。

{% endpanel %}

#### 保存现场

成功跳转到入口函数 `vecsys()` 之后，我们就要在软件上开始真正的异常处理过程了。但是，进行异常处理的时候不可避免地需要用到通用寄存器，然而看看现在的通用寄存器，里面存放的都是异常触发之前的内容。这些内容也是现场的一部分，如果不保存就覆盖它们，将来就无法恢复异常触发之前的状态了。但硬件并不负责保存它们，因此需要通过软件代码来保存它们的值。i386 提供了 `pusha` 指令，用于把通用寄存器的值压入堆栈。

`vecsys()` 会压入错误码和异常号 `#irq`，然后跳转到 `asm_trap()`。在 `asm_trap()` 中，代码将会把用户进程的通用寄存器保存到堆栈上。这些寄存器的内容连同之前保存的错误码，`#irq`，以及硬件保存的 EFLAGS, CS, EIP，形成了 trap frame（陷阱帧）的数据结构。我们知道栈帧记录了函数调用时的状态，而相应地，陷阱帧则完整记录了用户进程触发异常时现场的状态，将来恢复现场就靠它了。

{% panel style="info", title="对比异常与函数调用" %}

我们知道进行函数调用的时候也需要保存调用者的状态：返回地址，以及调用约定（calling convention）中需要调用者保存的寄存器。而进行异常处理之前却要保存更多的信息。尝试对比它们，并思考两者保存信息不同是什么原因造成的。

{% endpanel %}

注意到 trap frame 是在堆栈上构造的。接下来代码将会把当前的 `%esp` 压栈，并调用 C 函数 `irq_handle()` （在 `nexus-am/am/arch/x86-nemu/src/asye.c` 中定义）。

{% panel style="info", title="诡异的代码" %}

`trap.S` 中有一行 `pushl %esp` 的代码，乍看之下其行为十分诡异。你能结合前后的代码理解它的行为吗？**Hint:** 不用想太多，其实都是你学过的知识。

{% endpanel %}

{% panel style="danger", title="重新组织 TrapFrame 结构体" %}

你的任务如下:

- 实现 `pusha` 指令, 你需要注意压栈的顺序，更多信息请查阅 i386 手册。
- 理解 trap frame 形成的过程，然后重新组织 `nexus-am/am/arch/x86-nemu/include/arch.h` 中定义的 `_RegSet` 结构体的成员，使得这些成员声明的顺序和 `nexus-am/am/arch/x86-nemu/src/trap.S` 中构造的 trap frame 保持一致。

实现正确之后，`irq_handle()` 以及后续代码就可以正确地使用 trap frame 了。重新在 Nanos-lite 上运行 dummy 程序，你会看到在 `nanos-lite/src/irq.c` 中的 `do_event()` 函数中触发了 BAD TRAP：

```
[src/irq.c,5,do_event] {kernel} system panic: Unhandled event ID = 8
```

{% endpanel %}

#### 事件分发

`irq_handle()` 的代码会把异常封装成事件，然后调用在 `_asye_init()` 中注册的事件处理函数，将事件交给它来处理。在 Nanos-lite 中，这一事件处理函数是 `nanos-lite/src/irq.c` 中的 `do_event()` 函数。`do_event()` 函数会根据事件类型再次进行分发。我们刚才触发了一个未处理的 8 号事件，这其实是一个系统调用事件 `_EVENT_SYSCALL` （在 `nexus-am/am/am.h` 中定义）。在识别出系统调用事件后，需要调用 `do_syscall()` （在 `nanos-lite/src/syscall.c` 中定义）进行处理。

#### 系统调用处理

我们终于正式进入系统调用的处理函数中了。`do_syscall()` 首先通过宏 `SYSCALL_ARG1()` 从现场 `r` 中获取用户进程之前设置好的系统调用参数，通过第一个参数 - 系统调用号 - 进行分发。但目前 Nanos-lite 没有实现任何系统调用，因此触发了 panic。

添加一个系统调用比你想象中要简单，所有信息都已经准备好了。我们只需要在分发的过程中添加相应的系统调用号，并编写相应的系统调用处理函数 `sys_xxx()`，然后调用它即可。

回过头来看 `dummy` 程序，它触发了一个号码为 `0` 的 `SYS_none` 系统调用。我们约定，这个系统调用什么都不用做，直接返回 `1`。

处理系统调用的最后一件事就是设置系统调用的返回值。我们约定系统调用的返回值存放在系统调用号所在的寄存器中，所以我们只需要通过 `SYSCALL_ARG1()` 来进行设置就可以了。

#### 恢复现场

系统调用处理结束后，代码将会一路返回到 `trap.S` 的 `asm_trap()` 中。接下来的事情就是恢复用户进程的现场。`asm_trap()` 将根据之前保存的 trap frame 中的内容，恢复用户进程的通用寄存器（注意 trap frame 中的 `%eax` 已经被设置成系统调用的返回值了），并直接弹出一些不再需要的信息，最后执行 `iret` 指令。`iret` 指令用于从异常处理代码中返回，它将栈顶的三个元素来依次解释成EIP, CS, EFLAGS，并恢复它们。用户进程可以通过 `%eax` 寄存器获得系统调用的返回值，进而得知系统调用执行的结果。在它看来，这次时空之旅就好像没有发生过一样。

{% panel style="danger", title="实现系统调用" %}

你需要:

1. 在 `do_event()` 中识别出系统调用事件 `_EVENT_SYSCALL`，然后调用 `do_syscall()`。
2. 在 `nexus-am/am/arch/x86-nemu/include/arch.h` 中实现正确的 `SYSCALL_ARGx()` 宏，让它们从作为参数的现场 `reg` 中获得正确的系统调用参数寄存器。
3. 添加 `SYS_none` 系统调用。
4. 设置系统调用的返回值.
5. 实现 `popa` 和 `iret` 指令。

重新运行 dummy 程序，如果你的实现正确，你会看到 dummy 程序又触发了一个号码为 `4` 的系统调用。查看 `nanos-lite/src/syscall.h`，你会发现它是一个 `SYS_exit` 系统调用。这说明之前的 `SYS_none` 已经成功返回，触发 `SYS_exit` 是因为 dummy 已经执行完毕，准备退出了。

你需要实现 `SYS_exit` 系统调用，它会接收一个退出状态的参数，用这个参数调用 `_halt()` 即可。实现成功后，再次运行 dummy 程序，你会看到 GOOD TRAP 的信息。

{% endpanel %}

需要提醒的是，ASYE 还有其它的 API，但我们暂时不会用到，现在可以先忽略它们。

{% panel style="danger", title="温馨提示" %}

PA3 阶段 1 到此结束。

{% endpanel %}