# 不停计算的机器

在PA1中，我们已经见识到最简单的计算机 TRM 的工作方式：

```c
while (1) {
  从EIP指示的存储器位置取出指令;
  执行指令;
  更新EIP;
}
```

接下来我们就来谈谈这个过程，也就是，CPU究竟是怎么执行一条指令的。对于大部分指令来说，执行它们都可以抽象成**取指—译码—执行**的[指令周期](https://en.wikipedia.org/wiki/Instruction_cycle)。为了使描述更加清晰，我们借助指令周期中的一些概念来说明指令执行的过程。

{% panel style="info", title="追本溯源" %}

我们经常提的`指令`到底是从哪里来的呢？大家都知道，我们写的程序经过预处理、编译、汇编等过程之后会生成一个目标文件，这个文件一般是以二进制的形式存在我们的硬盘上。我们所谓的指令，便蕴藏在文件中存的一段段二进制比特串。例如这里有一条指令:

```
10111001 00110100 00010010 00000000 00000000
```

这究竟是什么……不过想想，计算机也只是个巨大的数字电路，它也只能理解0和1了。但是，为了方便人们阅读与理解，我们一般以十六进制和汇编语言组合的形式来表示这一段指令：

```
b8 34 12 00 00 			mov $0x1234,%eax
```

很明显，这段指令的意思是把 `eax` 寄存器赋值为 `0x1234`。其中 `b8` 是操作码(operation code)，对应汇编代码中的 `mov` 与 `%eax`，`34 12 00 00 ` 是操作数（operand），对应的是汇编代码的立即数`$0x1234`部分。

我们在执行一个程序的时候，首先要把这个二进制文件加载到内存（具体的加载过程在 `PA3` 会有详细介绍，现在可以理解为把指令的比特串从硬盘读到了内存的相应位置），光加载到内存还不够，CPU 还需要知道从内存的什么地方开始执行指令，这时 `eip` 寄存器便派上了用场，它会告诉 CPU 接下来要从内存的什么地方读取指令。

回想一下，我们在做简易调试器时，用来测试的指令的形式如下:

```
0x100000:	b8 34 12 00 00 			mov $0x1234,%eax
```

其中 `0x100000` 便是 `eip` 指向的地址。

有了内存中的指令与 `eip` 提供的地址，CPU 便可以开始它的工作了。

讲到这里，如果你还不理解指令是什么，你可以把它当做汇编代码的二进制表示，虽然这样定义有些不严谨。如果你想了解更多，可以参考[这里](https://en.wikipedia.org/wiki/Instruction_set_architecture)。

{% endpanel %}

## 指令执行过程

下面我们来谈一谈一条指令的执行周期。

### 取指(instruction fetch, IF)

取指令要做的事情自然就是将 `eip` 指向的指令从内存读入到CPU中。

### 译码(instruction decode, ID)

在取指阶段, 计算机拿到了将要执行的指令。然而，面对已经取到的这一串令人费解的01序列，计算机是如何理解它的意思的呢？

让我们先来回想一下指令是做什么的。我们知道CPU是用来处理数据的, 指令则是用来指示CPU具体对什么数据进行什么样的处理. 也就是说, 我们只要让CPU从取到的比特串中解读出处理的对象和处理的操作, CPU就知道我们想让它做什么了. 所以相应地, CPU需要从指令中解读出`操作数`和`操作码`两部分信息。

于是, 为了让计算机明白指令的含义, 先驱想到了一个办法, 那就是查找表! CPU拿到一条指令之后，**可以通过查表的方式得知这条指令的操作数和操作码**。这个过程叫译码。

当然, 译码逻辑实际上也并非只有一张查找表那么简单, 还需要根据不同的指令通过多路选择器选择不同的操作数. 回想一下, 计算机现在已经有存储器和寄存器了, 它们都可以存放操作数, 指令中也可以存放立即数. 也可能还有二次译码的处理……不过无论再怎么复杂, 我们只需要知道, 这个过程终究也只是一些数字电路的事情, 毕竟所有需要的信息都在指令里面了, 没什么神秘的操作.

### 执行(execute, EX)

经过译码之后, CPU 就知道当前指令具体要做什么了, 执行阶段就是真正完成指令的工作. 现在 TRM 只有加法器这一个执行部件, 必要的时候, 只需要往加法器输入两个源操作数, 就能得到执行的结果了. 之后还要把结果写回到目的操作数中, 可能是寄存器, 也可能是内存.

### 更新 `eip`

执行完一条指令之后, CPU就要执行下一条指令. 在这之前, CPU 需要更新 `%eip` 的值, 让 `%eip` 加上刚才执行完的指令的长度, 即可指向下一条指令的位置.

------

于是, 计算机不断地重复上述四个步骤, 不断地执行指令, 直到永远.

也许你会疑惑, 这个只能做加法的TRM, 究竟还能做些什么呢? 对于采用补码表示的计算机, 能做加法自然就能做减法. 如果再添加一条条件跳转指令`jne r, addr` ：当寄存器`r`不为`0`时, `eip` 跳转到`addr`处, TRM就大不一样了. 科学家证明了, 只要有`inc`,  `dec`,  `jne`这三条指令, 就可以实现"所有"的算法! (这里的"所有"是指可计算理论中的"所有可计算的算法") 也就是说, 现代计算机可以解决的纯粹的计算问题, 这个只有三条指令的TRM也可以解决. 例如通过 `jne` 和 `dec` 的组合可以实现循环, 循环执行 `inc` 可以实现任意数的加法, 循环执行加法可以实现乘法……甚至科学家还证明了, 仅仅通过这三条指令, 就可以编写一个和 NEMU 功能等价的程序! 这下可不得了了, 没想到这个弱不禁风的 TRM 竟然深藏着擎天撼地的威力! 不过, 虽然这个只有三条指令的 TRM 可以解决所有可计算的问题, 但却低效得让人无法忍受. 为此, 先驱决定往TRM中加入更多高效的指令.

## RTFM

我们在上一小节中已经在概念上介绍了一条指令具体如何执行, 其中有的概念甚至显而易见得难以展开. 不过x86这一庞然大物背负着太多历史的包袱, 但当我们决定往TRM中添加各种高效的x86指令时, 也同时意味着我们无法回避这些繁琐的细节.

首先你需要了解指令确切的行为, 为此, 你需要阅读 `i386手册` 中指令集相关的章节. [这里](../others/how-to-read-i386.md)有一个简单的阅读教程.

{% panel style="info", title="RISC: 与CISC平行的另一个世界" %}

你是否觉得x86指令集的格式特别复杂? 这其实是 CISC 的一个特性, 不惜使用复杂的指令格式, 牺牲硬件的开发成本, 也要使得一条指令可以多做事情, 从而提高代码的密度, 减小程序的大小. 随着时代的发展, 架构师发现 CISC 中复杂的控制逻辑不利于提高处理器的性能, 于是 RISC 应运而生. RISC 的宗旨就是简单, 指令少, 指令长度固定, 指令格式统一, 这和 KISS 法则有异曲同工之妙. [这里](http://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc)有一篇对比 RISC 和 CISC 的小短文.

另外值得推荐的是这篇文章, 里面讲述了一个从 RISC 世界诞生, 到与 CISC 世界融为一体的故事, 体会一下 RISC 的诞生对计算机体系结构发展的里程碑意义.

{% endpanel %}

## RTFSC(2)

NEMU 的作用之一就是实现上述整个 CPU 的执行过程，下面我们再次来介绍 NEMU 的框架代码，一层一层揭开它神奇的面纱。

### 数据结构

首先先对这个过程中的两个重要的数据结构进行说明.

- `nemu/src/cpu/exec/exec.c` 中的 `opcode_table` 数组. 这就是我们之前提到的译码查找表了, 这一张表通过操作码 `opcode` 来索引, 每一个 `opcode` 对应相应指令的译码函数, 执行函数, 以及操作数宽度.
- `nemu/src/cpu/decode/decode.c` 中的 `decoding` 结构. 它用于记录一些全局译码信息供后续使用, 包括操作数的类型, 宽度, 值等信息. 其中的 `src` 成员, `src2` 成员和 `dest` 成员分别代表两个源操作数和一个目的操作数. `nemu/include/cpu/decode.h` 中定义了三个宏 `id_src`, `id_src2` 和 `id_dest`, 用于方便地访问它们，分别对应于源操作数 1、源操作数 2 和目标操作数.

### 执行流程

#### exec_wrapper()

在PA1中我们知道，在 `cpu-exec()` 函数中调用了 `exec_wrapper()` 函数来进行指令执行的操作，所以下面将对`exec_wrapper()` 的执行过程进行简单介绍.

- 首先将当前的 `eip` 保存到全局译码信息 `decoding` 的成员 `seq_eip` 中,然后将其地址被作为参数送进`exec_real()` 函数中。`seq` 代表顺序的意思, 当代码从 `exec_real()` 返回时, `decoding.seq_eip` 将会指向下一条指令的地址.`exec_real()` 函数通过宏 `make_EHelper` 来定义:
  ```c
  #define make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)
  ```
  其含义是"定义一个执行阶段相关的helper函数", 这些函数都带有一个参数`eip`.（对于表达式中`concat`的含义，在下面会有介绍。NEMU通过不同的helper函数来模拟不同的步骤.


#### exec_real()

在 `exec_real()` 中:

- 首先通过 `instr_fetch()` 函数(在`nemu/include/cpu/exec.h`中定义)进行**取指**, 得到指令的第一个字节, 将其解释成 `opcode` 并记录在全局译码信息 `decoding` 中；
- 根据 `opcode` 查阅译码查找表, 得到操作数的宽度信息, 并通过调用 `set_width()` 函数将其记录在全局译码信息 `decoding` 中；
- 调用 `idex()` 对指令进行进一步的译码和执行。

#### idex()

`idex()` 函数会调用译码查找表中的相应的译码函数进行操作数的**译码**. 译码函数统一通过宏 `make_DHelper` 来定义(在 `nemu/src/cpu/decode/decode.c` 中):

```c
#define make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)
```

它们的名字主要采用 **i386 手册附录 A**中的操作数表示记号, 例如 `I2r` 表示将立即数移入寄存器, 其中 `I` 表示立即数, `2` 表示英文 `to`, `r` 表示通用寄存器, 更多的记号请参考 **i386 手册**. 译码函数会把指令中的操作数信息分别记录在全局译码信息 `decoding` 中。

这些译码函数会进一步分解成各种不同操作数的译码的组合, 以实现操作数译码的解耦. 操作数译码函数统一通过宏 `make_DopHelper` 来定义 (在 `nemu/src/cpu/decode/decode.c` 中, `decode_op_rm()` 除外):

```c
#define make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)
```

它们的名字主要采用 **i386 手册附录 A** 中的操作数表示记号. 操作数译码函数会把操作数的信息记录在结构体 `op` 中, 如果操作数在指令中, 就会通过 `instr_fetch()` 将它们从 `eip` 所指向的内存位置取出. 为了使操作数译码函数更易于复用, 函数中的 `load_val` 参数会控制是否需要将该操作数读出到全局译码信息 `decoding` 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用; 如果它仅仅是一个目的操作数, 就不需要从内存读出它的值了, 因为执行这条指令并不需要这个值, 而是将新数据写入相应的内存位置.

 `idex()` 函数中的译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的**执行**操作.  执行函数统一通过宏 `make_EHelper` 来定义, 它们的名字是指令操作本身. 执行函数通过 RTL 来描述指令真正的执行功能(RTL 将在下文介绍). 其中 `operand_write()` 函数(在 `nemu/src/cpu/decode/decode.c` 中定义) 会根据第一个参数中记录的类型的不同进行相应的写操作, 包括写寄存器和写内存.

从 `idex()` 返回后, `exec_real()` 最后会通过 `update_eip()` 对 `eip` 进行更新.

上文已经把一条指令在 NEMU 中执行的流程进行了大概的介绍. 如果觉得上文的内容不易理解, 可以结合[这个例子](https://nju-ics.gitbooks.io/ics2017-programming-assignment/content/exec.html)来 RTFSC. 但这个例子中会描述较多细节, 阅读的时候需要一定的耐心.

{% panel style="info", title="立即数背后的故事" %}

在`decode_op_I()`函数中通过`instr_fetch()`函数获得指令中的立即数. 别看这里就这么一行代码, 其实背后隐藏着针对字节序的慎重考虑. 我们知道x86是小端机, 当你使用高级语言或者汇编语言写了一个32位常数`0x1234`的时候, 在生成的二进制代码中, 这个常数对应的字节序列如下(假设这个常数在内存中的起始地址是x):

	x   x+1  x+2  x+3
	+----+----+----+----+
	| 34 | 12 | 00 | 00 |
	+----+----+----+----+

而大多数PC机都是小端架构(我们相信没有同学会使用IBM大型机来做PA), 当NEMU运行的时候, 

```c
op_src->imm = instr_fetch(eip, 4);
```

这行代码会将`34 12 00 00`这个字节序列原封不动地从内存读入`imm`变量中, 主机的CPU会按照小端方式来解释这一字节序列, 于是会得到`0x1234`, 符合我们的预期结果.

Motorola 68k系列的处理器都是大端架构的. 现在问题来了, 考虑以下两种情况:

- 假设我们需要将NEMU运行在Motorola 68k的机器上(把NEMU的源代码编译成Motorola 68k的机器码)
- 假设我们需要编写一个新的模拟器NEMU-Motorola-68k, 模拟器本身运行在x86架构中, 但它模拟的是Motorola 68k程序的执行

在这两种情况下, 你需要注意些什么问题? 为什么会产生这些问题? 怎么解决它们?

事实上不仅仅是立即数的访问, 长度大于1字节的内存访问都需要考虑类似的问题. 我们在这里把问题统一抛出来, 以后就不再单独讨论了.

{% endpanel %}





### 结构化程序设计

细心的你会发现以下规律:

- 对于同一条指令的不同形式, 它们的执行阶段是相同的. 例如`add_I2E`和`add_E2G`等, 它们的执行阶段都是把两个操作数相加, 把结果存入目的操作数.
- 对于不同指令的同一种形式, 它们的译码阶段是相同的. 例如`add_I2E`和`sub_I2E`等, 它们的译码阶段都是识别出一个立即数和一个`E`操作数.
- 对于同一条指令同一种形式的不同操作数宽度, 它们的译码阶段和执行阶段都是非常类似的. 例如`add_I2E_b`, `add_I2E_w`和`add_I2E_l`, 它们都是识别出一个立即数和一个E操作数, 然后把相加的结果存入`E`操作数.


这意味着, 如果独立实现每条指令不同形式不同操作数宽度的helper函数, 将会引入大量重复的代码. 需要修改的时候, 相关的所有helper函数都要分别修改, 遗漏了某一处就会造成bug, 工程维护的难度急速上升.

一种好的做法是把译码, 执行和操作数宽度的相关代码分离开来, 实现解耦, 也就是在程序设计课上提到的结构化程序设计. 在框架代码中, 实现译码和执行之间的解耦的是`idex()`函数, 它依次调用`opcode_table`表项中的译码和执行的helper函数, 这样我们就可以分别编写译码和执行的helper函数了. 实现操作数宽度和译码, 执行这两者之间的解耦的是`id_src`, `id_src2`和`id_dest`中的`width`成员, 它们记录了操作数宽度, 译码和执行的过程中会根据它们进行不同的操作, 通过同一份译码函数和执行函数实现不同操作数宽度的功能.

为了易于使用, 框架代码中使用了一些宏, 我们在这里把相关的宏整理出来, 供大家参考.

|              宏              |                         含义                          |
| :--------------------------: | :---------------------------------------------------: |
|    `nemu/include/macro.h`    |                                                       |
|           `str(x)`           |                      字符串`"x"`                      |
|        `concat(x, y)`        |                       token`xy`                       |
|   `nemu/include/cpu/reg.h`   |                                                       |
|        `reg_l(index)`        |                编码为`index`的32位GPR                 |
|        `reg_w(index)`        |                编码为`index`的16位GPR                 |
|        `reg_b(index)`        |                 编码为`index`的8位GPR                 |
| `nemu/include/cpu/decode.h`  |                                                       |
|           `id_src`           |        全局变量`decoding`中源操作数成员的地址         |
|          `id_src2`           |       全局变量`decoding`中2号源操作数成员的地址       |
|          `id_dest`           |       全局变量`decoding`中目的操作数成员的地址        |
|     `make_Dhelper(name)`     |         名为`decode_name`的译码函数的原型说明         |
|          `Dhelper`           |                指向译码函数的函数指针                 |
|   `nemu/src/cpu/decode.c`    |                                                       |
|    `make_Dophelper(name)`    |    名为`decode_op_name`的操作数译码函数的原型说明     |
|  `nemu/include/cpu/exec.h`   |                                                       |
|     `make_Ehelper(name)`     |          名为`exec_name`的执行函数的原型说明          |
|          `Ehelper`           |                指向执行函数的函数指针                 |
|       `print_asm(...)`       | 将反汇编结果的字符串打印到缓冲区`decoding.assembly`中 |
|     `suffix_char(width)`     |            操作数宽度`width`对应的后缀字符            |
| `print_asm_template1(instr)` |         打印单目操作数指令`instr`的反汇编结果         |
| `print_asm_template2(instr)` |         打印双目操作数指令`instr`的反汇编结果         |
| `print_asm_template3(instr)` |         打印三目操作数指令`instr`的反汇编结果         |

{% panel style="info", title="强大的宏" %}

如果你知道C++的"模板"功能, 你可能会建议使用它, 但事实上在这里做不到. 我们知道宏是在编译预处理阶段进行处理的, 这意味着宏的功能不受编译阶段的约束(包括词法分析, 语法分析, 语义分析); 而C++的模板是在编译阶段进行处理的, 这说明它会受到编译阶段的限制. 理论上来说, 必定有一些事情是宏能做到, 但C++模板做不到. 一个例子就是框架代码中的拼接宏`concat()`, 它可以把两个token连接成一个新的token; 而在C++模板进行处理的时候, 词法分析阶段已经结束了, 因而不可能通过C++模板生成新的token.

计算机世界处处都是tradeoff, 有好处自然需要付出代价. 由于处理宏的时候不会进行语法检查, 因为宏而造成的错误很有可能不会马上暴露. 例如以下代码:

```c
#define N 10;
int a[N];
```

在编译的时候, 编译器会提示代码的第2行有语法错误. 但如果你光看第2行代码, 你很难发现错误, 甚至会怀疑编译器有bug. 那宏到底要不要用呢? 一种客观的观点是, 在你可以控制的范围中使用. 这就像goto语句一样, 当你希望在多重循环中从最内层循环直接跳出所有循环, goto是最方便的做法. 但如果代码中到处都是goto, 已经严重影响到代码段的可读性了, 这种情况当然是不可取的.

{% endpanel %}

### 用RTL表示指令行为

NEMU使用[RTL](https://en.wikipedia.org/wiki/Register_transfer_language)(寄存器传输语言)来描述x86指令的行为. 这样做的好处是可以提高代码的复用率, 使得指令模拟的实现更加规整. 同时RTL也可以作为一种[IR](https://en.wikipedia.org/wiki/Intermediate_representation)(中间表示)语言, 将来可以很方便地引入[即时编译](https://en.wikipedia.org/wiki/Just-in-time_compilation)技术对NEMU进行优化, 即使你在PA中不一定有机会感受到这一好处.

下面我们对NEMU中使用的RTL进行一些说明, 首先是RTL寄存器的定义. RTL寄存器是RTL指令专门使用的寄存器. 在NEMU中, RTL寄存器统一使用`rtlreg_t`来定义, 而`rtlreg_t`(在`nemu/include/common.h`中定义)其实只是一个`uint32_t`类型:

```c
typedef uint32_t rtlreg_t;
```

在NEMU中, RTL寄存器只有以下这些

- x86的八个通用寄存器(在`nemu/include/cpu/reg.h`中定义)
- `id_src`, `id_src2`和`id_dest`中的访存地址`addr`和操作数内容`val`(在`nemu/include/cpu/decode.h`中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙
- 临时寄存器`t0~t3`(在`nemu/src/cpu/decode/decode.c`中定义)
- 0寄存器`tzero`(在`nemu/src/cpu/decode/decode.c`中定义), 它只能读出`0`, 不能写入

有了RTL寄存器, 我们就可以定义RTL指令对它们进行的操作了. 在NEMU中, RTL指令有两种(在`nemu/include/cpu/rtl.h`中定义). 一种是RTL基本指令, 它们的特点是在即时编译技术里面可以只使用一条机器指令来实现相应的功能, 同时也不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作. RTL基本指令包括:

- 立即数读入`rtl_li`
- 算术运算和逻辑运算, 包括寄存器-寄存器类型`rtl_(add|sub|and|or|xor|shl|shr|sar|slt|sltu)` 和立即数-寄存器类型`rtl_(add|sub|and|or|xor|shl|shr|sar|slt|sltu)i`
- 内存的访存`rtl_lm`和`rtl_sm`
- 通用寄存器的访问`rtl_lr_(b|w|l)`和`rtl_sr_(b|w|l)`

第二种RTL指令是RTL伪指令, 它们是通过RTL基本指令或者已经实现的RTL伪指令来实现的, 包括:

- 带宽度的通用寄存器访问`rtl_lr`和`rtl_sr`
- EFLAGS标志位的读写`rtl_set_(CF|OF|ZF|SF|IF)`和`rtl_get_(CF|OF|ZF|SF|IF)`
- 其它常用功能, 如数据移动`rtl_mv`, 符号扩展`rtl_sext`等

其中大部分RTL伪指令还没有实现, 必要的时候你需要实现它们. 有了这些RTL指令之后, 我们就可以方便地通过若干条RTL指令来实现每一条x86指令的行为了.

### 实现新指令

对译码, 执行和操作数宽度的解耦实现以及RTL的引入对NEMU中实现一条新的x86指令提供了很大的便利, 为了实现一条新指令, 你只需要

1. 根据i386手册的介绍，在`opcode_table`中填写正确的译码函数, 执行函数以及操作数宽度；
2. 用RTL实现正确的执行函数, 需要注意使用RTL伪指令时不要把临时变量中有意义的值覆盖了；
3. 在`nemu/src/cpu/exec/all-instr.h`中声明已经实现好的执行函数

框架代码把绝大部分译码函数和执行函数都定义好了, 你可以很方便地使用它们.

如果你读过上文的扩展阅读材料中关于RISC与CISC融为一体的故事, 你也许会记得CISC风格的x86指令最终被分解成RISC风格的微指令在计算机中运行, 才让x86在这场扩日持久的性能大战中得以存活下来的故事. 如今NEMU在经历了第二次重构之后, 也终于引入了RISC风格的RTL来实现x86指令, 这也许是冥冥之中的安排吧.

## 运行第一个C程序

说了这么多, 现在到了动手实践的时候了. 你在PA2的第一个任务, 就是实现若干条指令, 使得第一个简单的C程序可以在NEMU中运行起来. 这个简单的C程序的代码是`nexus-am/tests/cputest/tests/dummy.c`, 它什么都不做就直接返回了. 在`nexus-am/tests/cputest`目录下键入

```bash
make ARCH=x86-nemu ALL=dummy run
```

编译`dummy`程序, 并启动NEMU运行它. 事实上, 并不是每一个程序都可以在NEMU中运行, `nexus-am/`子项目专门用于编译出能在NEMU中运行的程序, 我们在下一小节中会再来介绍它.

在NEMU中运行`dummy`程序, 你会发现NEMU输出以下信息:

```
invalid opcode(eip = 0x0010000a): e8 01 00 00 00 90 55 89 ...

There are two cases which will trigger this unexpected exception:
1. The instruction at eip = 0x0010000a is not implemented.
2. Something is implemented incorrectly.
Find this eip value(0x0010000a) in the disassembling result to distinguish which case it is.

If it is the first case, see
 _ ____   ___    __    __  __                         _ 
(_)___ \ / _ \  / /   |  \/  |                       | |
 _  __) | (_) |/ /_   | \  / | __ _ _ __  _   _  __ _| |
| ||__ < > _ <| '_ \  | |\/| |/ _  | '_ \| | | |/ _  | |
| |___) | (_) | (_) | | |  | | (_| | | | | |_| | (_| | |
|_|____/ \___/ \___/  |_|  |_|\__,_|_| |_|\__,_|\__,_|_|

for more details.

If it is the second case, remember:
* The machine is always right!
* Every line of untested code is always wrong!
```

这是因为你还没有实现以`0xe8`为首字节的指令, 因此, 你需要开始在NEMU中添加指令了.

要实现哪些指令才能让`dummy`在NEMU中运行起来呢? 答案就在其反汇编结果(`nexus-am/tests/cputest/build/dummy-x86-nemu.txt`)中. 查看反汇编结果, 你发现只需要添加`call`, `push`, `sub`, `xor`, `pop`, `ret`六条指令就可以了. 每一条指令还有不同的形式, 根据KISS法则, 你可以先实现只在`dummy`中出现的指令形式, 通过指令的`opcode`可以确定具体的形式.

{% panel style="danger", title="请查阅i386手册" %}

这里要再次强调, 你务必通过i386手册来查阅指令的功能, 不能想当然.手册中给出了指令功能的完整描述(包括做什么事, 怎么做的, 有什么影响),一定要仔细阅读其中的每一个单词, 对指令功能理解错误和遗漏都会给以后的调试带来巨大的麻烦. **同时，一定要结合勘误来看，否则你的很多努力都会前功尽弃!**

{% endpanel %}

### 编写RTL函数

因为实现指令的执行函数要用到许多RTL函数，请你在`nemu/include/cpu/rtl.h`中，**根据提示**实现每一条RTL函数。**注意：RTL是整个框架的最底层部分，如果有一处出现差错，之后会有无数难以调试的bug在等待着你！请在实现的过程务必保持头脑清醒，按照提示来实现！**

### 实现指令

- `call`: `call`指令有很多形式, 不过在PA中只会用到其中的几种, 现在只需要实现`CALL rel32`的形式就可以了. `%eip`的跳转可以通过将`decoding.is_jmp`设为`1`, 并将`decoding.jmp_eip`设为跳转目标地址来实现, 这时在`update_eip()`函数中会把跳转目标地址作为新的`%eip`, 而不是顺序意义下的下一条指令的地址

- `push`, `pop`: 现在只需要实现`PUSH r32`和`POP r32`的形式就可以了, 它们可以很容易地通过`rtl_push`和`rtl_pop`来实现

- `sub`: 在实现`sub`指令之前, 你首先需实现EFLAGS寄存器.你只需要在寄存器结构体中添加EFLAGS寄存器即可.EFLAGS是一个32位寄存器, 它的结构如下:

  ```
   31                  23                  15               7             0
   +-------------------+-------------------+-------+-+-+-+-+-+-+-------+-+-+
   |                                               |O| |I| |S|Z|       |  |C|
   |                       X                       | |X| |X| | |   X   |1| |
   |                                               |F| |F| |F|F|       | |F|
   +-------------------+-------------------+-------+-+-+-+-+-+-+-------+-+-+
  ```
  在NEMU中, 我们只会用到EFLAGS中以下的5个位: `CF`, `ZF`, `SF`, `IF`, `OF`,标记成`X`的位不必关心, 它们的功能可暂不实现.关于EFLAGS中每一位的含义, 请查阅i386手册.添加EFLAGS寄存器需要用到结构体的位域(bit field)功能, 如果你从未听说过位域, 请查阅相关资料.
  关于EFLGAS的初值, 我们遵循i386手册中提到的约定,你需要在i386手册的第10章中找到这一初值, 然后在`restart()`函数中对EFLAGS寄存器进行初始化.实现了EFLAGS寄存器之后, 再实现相关的RTL指令, 之后你就可以通过这些RTL指令来实现`sub`指令了

- `xor`, `ret`: RTFM吧

 {% panel style="success", title="神奇的eflags(1)" %}

在`x86`体系下，`eflags`在程序的运行过程中发挥了巨大的作用，除了每个标志位本身的含义，标志位之前的各种组合可以为程序跳转条件的判断提供很大的依据。在这里希望你能结合实现`sub`指令的过程回答如下问题。

* `OF`的作用是判断是否有溢出, 这里的“溢出”是什么意思呢?  如果只用仅为标志位`CF`可不可以代替`OF`的功能呢？为什么？
* 在运算的过程中如何获得`OF`的值？

{% endpanel %} 



{% panel style="danger", title="运行第一个客户程序" %}

在NEMU中通过RTL指令实现上文提到的指令, 具体细节请务必参考i386手册.实现成功后, 在NEMU中运行客户程序`dummy`, 你将会看到`HIT GOOD TRAP`的信息.

{% endpanel %}



{% panel style="danger", title="温馨提示" %}

PA2阶段1到此结束.

{% endpanel %}

